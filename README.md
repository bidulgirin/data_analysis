# 시험볼것

- 넘파이배열로 바꾸기 

import numpy as np # 먼저 import 
lst_arr = np.array(리스트나튜플)

# 차원 찍어보기
lst_arr.ndim

# 다차원 배열을 1차원 배열로 바꾸는 
arr2d.flatten()

# 넘파이배열을 리스트로 변환
lst2d = arr2d.tolist() 

다차원배열은 행과 열의 인덱스를 "튜플"로 조회가능
arr2d[(0,0)] 


# 만들어주기
m = np.arange(15).reshape(-1,5) # 15개의 데이터를 5개의 데이터로 나눌것이다 3행이 생기겠죠,,,,

# 전치하다! ( 아 아 이것은 pandas 때 배운것이다...)
arr_transport = arr.T



# 유니버셜 함수
type(np.add) : numpy.ufunc


# 연산

np.add(lst2d , lst2d)

# 벡터화 연산
a와 b 는 넘파이배열이라고 할것이다.

a * b
a / b
a % b
a ^ b
a & b
a != b
(a == 2) & (b > 10)



new_arr2 = arr2.reshape(-1, 4)
np.add(new_arr2 ,new_arr2) # 반복확장해버린다고???



# 행렬 곱
a @ b





# 브로드캐스팅----------------------
# 반복확장이라는 개념 
===>부족한 열/행이 확장된다 

# 축에 따른 연산----------------------

arr1 = np.array([1,2,3,4])

# 연산들...
np.sum(arr1)
arr1.max()
rr1.min()


# 최소값의 위치 뽑아내는함수
arr1.argmin()
# 최대값의 위치 뽑아내는함수
arr1.argmax()

arr1.mean()
np.median(arr1)


# 2차원 배열----------------------
# 집계는 필수적으로 차원이 줄어들어요!
# 집계는 필수적으로 차원이 줄어들어요!
# 집계는 필수적으로 차원이 줄어들어요!
# 집계는 필수적으로 차원이 줄어들어요!
# 집계는 필수적으로 차원이 줄어들어요!
# 집계는 필수적으로 차원이 줄어들어요!
# 집계는 필수적으로 차원이 줄어들어요!


np.sum(arr2, axis=0) : 행을 기준으로 합쳐집니다. 행을 뚫는다. => 열shape 만 남는다


# 잘 읽기 
행 기준으로 합쳐지는지 전체 행을 합치는지


# 랜덤으로 뭘 생성하고...
arr3 = np.random.randint(0, 3, size = (2,3)) # 3개의 데이터를 가진 2개의 행을 만들겠다...



# 3차원에서의 shape 를 만드시오

arr5 = np.random.randint(0,3, size = (2,3,4))
np.sum(arr5 axis=(0,1))

4개의 데이터를 가진 3행의 그룹 2개...

(2,3,4) 이렇게 나올것이여
np.sum(arr5, axis = (0,1))이렇게 하면 
3차원과 2차원을 합쳐버리겠다~ 라고 하는거잖아요?
4, 이렇게 4개의 데이터만 남을것이여

그룹2개를 각 행과 인덱스가 맞는게 합쳐지고
2차원이 합쳐진다...라고 하였으니 행끼리의 인덱스가 동일한 값이 더해져서 

압축! 압축! 한 4개의 데이터를 가진 1차원 배열이 나오게 되는거죵....
[ㅁ,ㅠ,ㅇ,ㅇ]

# inf 와 nan 

np.array([0,1,-1,0]) /np.array([1,0,-0,0])
array([  0.,  inf, -inf,  nan]) 



# 용어가 헷갈려? 외워...
data_3d = np.random.random((3,5,6)) 로 배열을 만들었음

# 각 2차원 배열에서의 열의 평균
np.mean(data_3d, axis=1) : "행을 기준"으로 열들의 평균을 구하니까

# 각 2차원 배열에서의 각 열의 최솟값
np.min(data_3d, axis=1) # 행을기준으로 행을 뚫고 지나가는 데이터들의 최솟값...

# 전체 열의 평균
np.mean(data_3d, axis=(0,1)) : 차원합쳐야하고, 열들을 집계해야하므로 행을 뚫고지나감 axis = 1

# 각 2차원 배열에서의 각 행의 최댓값
np.max(data_3d, axis=2) : 각 행의 최댓값 행들을 비교해야하니까 열기준작대기가 뚫고 지나가죠? axis = 2

# 각 2차원 배열에서의 행의 합 
np.sum(data_3d, axis=2) : 행들을 합쳐야하니까 열을뚫고지나가는 데이터들의 집계...

# 각 2차원 배열에서의 최댓값
np.max(data_3d , axis=(1,2)) : 각 2차원에서 의 최댓값 이라면 행과 열을 모두 뭉게야하니까 1,2 를 축으로 적어두죠


# 스칼라와 백터

텐서가 0 차원인 경우(축이 없는경우) : 스칼라
1차원인 하나의 축을 가진 경우: 벡터
2차원인 2개의 축을 가진경우 : 행렬
3차원인 3개의 축을 가진 경우 : 큐브 또는 3차원 텐서
더 차원이 높은 경우는 차원을 기준으로 n차원 텐서라고 부름



# 빈배열을 만든다
zero_arr = np.zeros(5) 
zero_arr3 = np.zeros((2,3,4), dtype= int)
one_arr = np.ones((2,3,4), dtype = int)
zero_arr4 = np.zeros_like(one_arr)


# 원소의 개수
vector1.size







